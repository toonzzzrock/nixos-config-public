# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{
  config,
  lib,
  pkgs,
  modulesPath,
  ...
}:
{
  imports = [ (modulesPath + "/installer/scan/not-detected.nix") ];

  systemd.services."sys-fs-pstore.mount".enable = false;
  systemd.services."systemd-pstore".enable = false;
  systemd.services."modprobe@efi_pstore".enable = false;
  console = {
    enable = false;
  };
  boot = {
    consoleLogLevel = 3;
    enableContainers = lib.mkForce false;
    tmp = {
      # useTmpfs = true;
      useZram = true;
    };
    # plymouth = {
    #   enable = true;

    #   # add theme package and name
    #   themePackages = lib.mkForce [pkgs.mikuboot];
    #   theme = lib.mkForce "mikuboot";
    # };

    kernelModules = [
      #   "kvm-intel"
      "i915"
      # "nvidia"
      # "nvidia_modeset"
      # "nvidia_uvm"
      # "nvidia_drm"
    ];
    # kernelModules = [ ];

    initrd = {
      availableKernelModules = [
        "vmd"
        "ahci"
        "nvme"
        "sd_mod"
      ];
      # systemd.services.systemd-udevd.after = [ "systemd-modules-load.service" ];
      compressor = "cat";
      verbose = false;
    };

    extraModulePackages = [ config.hardware.nvidia.package ];
    loader = {
      systemd-boot.enable = true;
      systemd-boot.consoleMode = "auto";
      efi.canTouchEfiVariables = true;
      timeout = 0;
    };
    kernelPackages = pkgs.linuxPackages_cachyos-lto; # .cachyOverride { mArch = "GENERIC_V4"; };

    kernelParams = [
      # "quiet"
      "rd.systemd.show_status=false"
      "rd.udev.log_level=3"

      "cgroup_no_v1=all"
      "systemd.unified_cgroup_hierarchy=yes"

      "preempt=full"

      "mitigations=off"

      "i915.enable_psr=0"
      "i915.enable_guc=3"
      "i915.lvds_downclock=1"

      "acpi=rsdt"

      "nmi_watchdog=0"
      "nowatchdog"

      "libahci.ignore_sss=1"
      "video=efifb:auto"

      "systemd.gpt_auto=no"
      "intel_iommu=on"
      "iommu=pt"
      "threadirqs"

      "nvidia.NVreg_PreserveVideoMemoryAllocations=0"
      "NVreg_RegistryDwords=RmEnableAggressiveVblank=1"

      "random.trust_cpu=on"
      "rcutree.enable_rcu_lazy=1"

      "ahci.mobile_lpm_policy=3"
      "rootdelay=0"

      "usbcore.autosuspend=-1"
      "nvme.noacpi=1"
      "nvme_core.default_ps_max_latency_us=0"
      "pcie_aspm=force"
      "split_lock_detect=off"
    ];
    kernel.sysctl = {
      "kernel.split_lock_mitigate" = 0;

      # Congestion control (BBR is great on high BDP/long fat pipes; on LAN, cubic is fine)
      "net.ipv4.tcp_congestion_control" = "bbr";

      # Larger autotune buffers for high throughput links (don’t overdo on small RAM)
      "net.core.rmem_max" = 536870912;
      "net.core.wmem_max" = 536870912;
      "net.ipv4.tcp_rmem" = "8192 262144 536870912";
      "net.ipv4.tcp_wmem" = "4096 16384 536870912";

      # Recover from bad PMTUs
      "net.ipv4.tcp_mtu_probing" = 1;

      # Reduce head‑of‑line for unsent data; can lower latency on busy writers
      "net.ipv4.tcp_notsent_lowat" = 131072; # try 64k–256k; 0 means unlimited

      "net.ipv4.tcp_moderate_rcvbuf" = 1;
      "net.ipv4.tcp_fastopen" = 3;
      "net.core.default_qdisc" = "fq"; # or cake
      "vfs_cache_pressure" = 1;
      "vm.laptop_mode" = 5;
      "vm.dirty_writeback_centisecs" = 6000;
      "vm.dirty_expire_centisecs" = 6000;
      "vm.dirty_ratio" = 5;
      "vm.dirty_background_ratio" = 2;
      "vm.swappiness" = 100; # https://discourse.nixos.org/t/how-can-i-see-if-my-system-is-using-my-swap-partition/47803/14

      "net.core.netdev_max_backlog" = 250000;
      "net.core.rmem_default" = 8388608;
      "net.core.wmem_default" = 8388608;
      "net.core.optmem_max" = 40960;
      "net.ipv4.tcp_synack_retries" = 5;
      "net.ipv4.ip_local_port_range" = "1024 65535";
      "net.ipv4.tcp_slow_start_after_idle" = 0;
      "net.ipv4.tcp_base_mss" = 1024;
      "net.ipv4.tcp_adv_win_scale" = -2;

      # Name: K4YT3X's Hardened & Optimized Linux Kernel Parameters

      "kernel.randomize_va_space" = 2;

      # controls the System Request debugging functionality of the kernel
      "kernel.sysrq" = 0;

      # controls whether core dumps will append the PID to the core filename
      # useful for debugging multi-threaded applications
      "kernel.core_uses_pid" = 1;

      # restrict access to kernel address
      # kernel pointers printed using %pK will be replaced with 0’s regardless of privileges
      "kernel.kptr_restrict" = 2;

      # Ptrace protection using Yama
      #   - 0 (classic): allows any process to trace any other process under the same UID
      #   - 1 (restricted): only a parent process can be debugged
      #   - 2 (admin-only): only admins can use ptrace (CAP_SYS_PTRACE capability required)
      #   - 3 (no attach): disables ptrace completely, reboot is required to re-enable ptrace
      # the general recommendation for this setting is:
      #   - if you do not need to debug programs, set it to 3
      #   - if you need to debug programs (e.g., GDB, LLDB, strace), set it to 1
      # setting it to 3 will also break LXC v6+ procfs emulation for unprivileged containers
      #   (see GitHub issue https://github.com/lxc/lxcfs/issues/636)
      "kernel.yama.ptrace_scope" = 3;

      # restrict kernel logs to root only
      "kernel.dmesg_restrict" = 1;

      # disables kexec as it can be used to livepatch the running kernel
      "kernel.kexec_load_disabled" = 1;

      # disable the loading of kernel modules
      # this can be used to prevent runtime insertion of malicious modules
      # could break the system if enabled within sysctl.conf
      # consider setting this manually after system is up
      # sudo sysctl -w kernel.modules_disabled=1
      #kernel.modules_disabled = 1

      # allow for more PIDs
      # this value can be up to:
      #   - 32768 (2^15) on a 32-bit system
      #   - 4194304 (2^22) on a 64-bit system

      # reboot machine after kernel panic
      #kernel.panic = 10

      # restrict perf subsystem usage
      # prevent unprivileged attackers from loading vulnerable line disciplines with the TIOCSETD ioctl
      "dev.tty.ldisc_autoload" = 0;

      ########## File System ##########

      # disallow core dumping by SUID/SGID programs
      "fs.suid_dumpable" = 0;

      # protect the creation of hard links
      # one of the following conditions must be fulfilled
      #   - the user can only link to files that he or she owns
      #   - the user must first have read and write access to a file, that he/she wants to link to
      "fs.protected_hardlinks" = 1;

      # protect the creation of symbolic links
      # one of the following conditions must be fulfilled
      #   - the process following the symbolic link is the owner of the symbolic link
      #   - the owner of the directory is also the owner of the symbolic link
      "fs.protected_symlinks" = 1;

      # enable extended FIFO protection
      "fs.protected_fifos" = 2;

      # similar to protected_fifos, but it avoids writes to an attacker-controlled regular file
      "fs.protected_regular" = 2;

      ########## Networking ##########

    };

    # https://github.com/positron-solutions/derpconfig/blob/master/examples/kernel-clang.nix
    kernelPatches = [
      {
        name = "Rust Support";
        patch = null;
        features = {
          rust = true;
        };
      }
    ];

    # modprobeConfig.enable = true;
    # modprobeConfig.useUbuntuModuleBlacklist = true;

  };

  services.scx = {
    enable = true;
    package = pkgs.scx_git.rustscheds;
    scheduler = "scx_cosmos";
  };
  boot.initrd.systemd.settings.Manager = {
    DefaultTimeoutStopSec = "5s";
    DefaultTimeoutStartSec = "5s";
    DefaultLimitNOFILE = 4096;
    RebootWatchdogSec = "5s";
    RuntimeWatchdogSec = "5s";
  };
  systemd.settings.Manager = {
    DefaultTimeoutStopSec = "5s";
    DefaultTimeoutStartSec = "5s";
    DefaultLimitNOFILE = 4096;
    RebootWatchdogSec = "5s";
    RuntimeWatchdogSec = "5s";
  };

  zramSwap = {
    enable = true;
    algorithm = "lz4";
    priority = 100;
    memoryPercent = 50;
  };

  fileSystems."/" = {
    device = "/dev/disk/by-uuid/b4ca0f25-3031-4663-b9ea-0819f305e5ef";
    fsType = "btrfs";
    options = [
      "subvol=@"
      "noatime"
      "lazytime"
      "compress=zstd:3"
      "discard=async"
      "space_cache=v2"
      "commit=60"
      "ssd"
    ];
  };

  fileSystems."/boot" = {
    device = "/dev/disk/by-uuid/762A-A7F8";
    fsType = "vfat";
    options = [
      "fmask=0077"
      "dmask=0077"
    ];
  };

  swapDevices = [ ];

  # Enables DHCP on each ethernet and wireless interface. In case of scripted networking
  # (the default) this is the recommended approach. When using systemd-networkd it's
  # still possible to use this option, but it's recommended to use it in conjunction
  # with explicit per-interface declarations with `networking.interfaces.<interface>.useDHCP`.

  # networking.interfaces.eth0.useDHCP = false;
  # networking.interfaces.wlp0s20f3.useDHCP = lib.mkDefault true;

  # nixpkgs.hostPlatform = lib.mkDefault "x86_64-linux";
  nix.settings.system-features = [
    "big-parallel"
    "gccarch-x86-64-v4"
  ];
  nixpkgs.hostPlatform = {
    # gcc.arch = "tigerlake";
    # gcc.tune = "tigerlake";
    system = "x86_64-linux";
  };
  hardware.enableAllFirmware = lib.mkDefault true;
  hardware.cpu.intel.updateMicrocode = lib.mkDefault config.hardware.enableRedistributableFirmware;
}
